/*  ============================================================================================================ *

                                    주 의 사 항


    1. 주석으로 표현된 구현 블록 0에서 12번까지 구현하여 128비트 AES 암호화 알고리즘을 구현해야 함
    2. AES128(...) 함수의 호출과 리턴이 여러번 반복되더라도 메모리 누수가 생기지 않게 함
    3. AddRoundKey 함수를 구현할 때에도 파라미터 rKey는 사전에 선언된 지역 배열을 가리키도록 해야 함
       (정확한 구현을 위해서는 포인터 개념의 이해가 필요함)
    4. 배열의 인덱스 계산시 아래에 정의된 KEY_SIZE, ROUNDKEY_SIZE, BLOCK_SIZE를 이용해야 함
       (상수 그대로 사용하면 안됨. 예로, 4, 16는 안되고 KEY_SIZE/4, BLOCK_SIZE로 사용해야 함)

 *  ============================================================================================================ */

#include <stdio.h>
#include <stdlib.h>
#include "AES128.h"

#define KEY_SIZE 16
#define ROUNDKEY_SIZE 176
#define BLOCK_SIZE 16


/*********************************************** { 구현 0 시작 } ********************************************/



/*********************************************** { 구현 0 종료 } ********************************************/


/*  <키스케줄링 함수>
 *   
 *  key         키스케줄링을 수행할 16바이트 키
 *  roundKey    키스케줄링의 결과인 176바이트 라운드키가 담길 공간
 */
void expandKey(BYTE *key, BYTE *roundKey){

    /*********************************************** { 구현 1 시작 } ********************************************/




    /*********************************************** { 구현 1 종료 } ********************************************/

}


/*  <SubBytes 함수>
 *   
 *  block   SubBytes 수행할 16바이트 블록. 수행 결과는 해당 배열에 바로 반영
 *  mode    SubBytes 수행 모드
 */
 BYTE* subBytes(BYTE *block, int mode){

    /* 필요하다 생각하면 추가 선언 */

    switch(mode){

        case ENC:
            /*********************************************** { 구현 2 시작 } ********************************************/




            /*********************************************** { 구현 2 종료 } ********************************************/            
            break;

        case DEC:
            /*********************************************** { 구현 3 시작 } ********************************************/




            /*********************************************** { 구현 3 종료 } ********************************************/
            break;

        default:
            fprintf(stderr, "Invalid mode!\n");
            exit(1);
    }
    
    return block;
}


/*  <ShiftRows 함수>
 *   
 *  block   ShiftRows 수행할 16바이트 블록. 수행 결과는 해당 배열에 바로 반영
 *  mode    ShiftRows 수행 모드
 */
BYTE* shiftRows(BYTE *block, int mode){ 

    /* 필요하다 생각하면 추가 선언 */   

    switch(mode){

        case ENC:
            /*********************************************** { 구현 4 시작 } ********************************************/




            /*********************************************** { 구현 4 종료 } ********************************************/            
            break;

        case DEC:
            /*********************************************** { 구현 5 시작 } ********************************************/




            /*********************************************** { 구현 5 종료 } ********************************************/
            break;

        default:
            fprintf(stderr, "Invalid mode!\n");
            exit(1);
    }
    
    return block;
}


/*  <MixColumns 함수>
 *   
 *  block   MixColumns을 수행할 16바이트 블록. 수행 결과는 해당 배열에 바로 반영
 *  mode    MixColumns의 수행 모드
 */
BYTE* mixColumns(BYTE *block, int mode){    

    /* 필요하다 생각하면 추가 선언 */   

    switch(mode){

        case ENC:
            /*********************************************** { 구현 6 시작 } ********************************************/




            /*********************************************** { 구현 6 종료 } ********************************************/            
            break;

        case DEC:
            /*********************************************** { 구현 7 시작 } ********************************************/




            /*********************************************** { 구현 7 종료 } ********************************************/
            break;

        default:
            fprintf(stderr, "Invalid mode!\n");
            exit(1);
    }
    
    return block;
}


/*  <AddRoundKey 함수>
 *   
 *  block   AddRoundKey를 수행할 16바이트 블록. 수행 결과는 해당 배열에 반영
 *  rKey    AddRoundKey를 수행할 16바이트 라운드키
 */
BYTE* addRoundKey(BYTE *block, BYTE *rKey){

    /*********************************************** { 구현 8 시작 } ********************************************/




    /*********************************************** { 구현 8 종료 } ********************************************/

    return block;
}


/*  <128비트 AES 암호화 함수>
 *   
 *  plain   바이트 배열로 구성된 평문 (16바이트 고정)
 *  key     128비트 암호키 (16바이트)
 *
 *  @ret    암호화된 암호문
 */
BYTE* encrypt(BYTE *plain, BYTE *key){
    BYTE roundKey[ROUNDKEY_SIZE];

    /*********************************************** { 구현 9 시작 } ********************************************/




    /*********************************************** { 구현 9 종료 } ********************************************/
}


/*  <128비트 AES 복호화 함수>
 *   
 *  cipher  바이트 배열로 구성된 평문 (16바이트 고정)
 *  key     128비트 암호키 (16바이트)
 *
 *  @ret    복호화된 평문
 */
BYTE* decrypt(BYTE *cipher, BYTE *key){
    BYTE roundKey[ROUNDKEY_SIZE];
    
    /*********************************************** { 구현 10 시작 } ********************************************/




    /*********************************************** { 구현 10 종료 } ********************************************/
}


/*  <128비트 AES 암복호화 함수>
 *  
 *  mode가 ENC일 경우 평문을 암호화하고, DEC일 경우 암호문을 복호화하는 함수
 *
 *  [ENC 모드]
 *  plain   평문 바이트 배열
 *  cipher  결과(암호문)이 담길 바이트 배열. 호출하는 사용자가 사전에 메모리를 할당하여 파라미터로 넘김
 *  key     128비트 암호키 (16바이트)
 *
 *  [DEC 모드]
 *  plain   결과(평문)가 담길 바이트 배열. 호출하는 사용자가 사전에 메모리를 할당하여 파라미터로 넘김
 *  cipher  암호문 바이트 배열
 *  key     128비트 암호키 (16바이트)
 */
void AES128(BYTE *plain, BYTE *cipher, BYTE *key, int mode){
    BYTE *tmp;  

    if(mode == ENC){
        tmp = encrypt(plain, key);

        /*********************************************** { 구현 11 시작 } ********************************************/



        /*********************************************** { 구현 11 종료 } ********************************************/ 

    }else if(mode == DEC){
        tmp = decrypt(cipher, key);

        /*********************************************** { 구현 12 시작 } ********************************************/



        /*********************************************** { 구현 12 종료 } ********************************************/ 

    }else{
        fprintf(stderr, "Invalid mode!\n");
        exit(1);
    }
}
